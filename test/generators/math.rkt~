#lang racket

(define maximum-literal 1000000)
(define maximum-params 10)
(define maximum-depth 3)
(define count 1)

(define operations (vector
                    (cons + '+)
                    (cons - '-)
                    (cons * '*)
                    (cons / '/)))

(define (random-expr max-depth)
  (cond
    [(zero? max-depth) (random-literal)]
    [else (let
              [(operation (random (add1 (vector-length operations))))]
            (if (= operation (vector-length operations))
                (random-literal)
                (let* [
                       (op (vector-ref operations operation))
                       (op-fn (car op))
                       (op-sym (cdr op))
                       (params (random-expr-list (random (add1 maximum-params)) (sub1 max-depth)))
                       (param-trees (map car params))
                       (param-values (map cdr params))]
                  (cons
                   (cons op-sym param-trees)
                   (apply op-fn param-values)))))]))

(define (random-literal) (let [(r (random (add1 maximum-literal)))]
                           (cons r r)))

(define (random-expr-list count max-depth)
  (with-handlers ([exn:fail? (lambda (exn) (random-expr-list count max-depth))])
    (if (zero? count)
        empty
        (cons (random-expr max-depth) (random-expr-list (sub1 count) max-depth)))))

(for-each
 (lambda (v)
   (write (car v)) (newline)
   (write (cdr v) (current-error-port)) (newline (current-error-port)))
 (random-expr-list count maximum-depth))